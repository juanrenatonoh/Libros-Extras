<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)http://users.vr9.com/wktrelz/tktk/eporc1.htm -->
<html>

<head>
<title>WKT -- COMO CRACKEAR POR ESTADO+PORCINO --</title>
<meta content="text/html; charset=windows-1252" http-equiv="Content-Type">


<meta content="Microsoft FrontPage 3.0" name="GENERATOR">
</head>

<body aLink="#efff2f" bgColor="#000000" link="#c00061" text="#ffffff" vLink="#00670e">

<p align="center"><br>
</p>
<div align="center"><center>

<table border="2">
<TBODY>
  <tr>
    <td align="middle" bgColor="#ffcc33" vAlign="center"><b><font color="#ffffff" face="Arial"
    size="+2">COMO CRAKEAR POR ESTADO+PORCINO</font> </b></td>
  </tr>
</TBODY>
</table>
</center></div>

<p align="center"><br>
<br>
</p>
<div align="center"><center>

<table border="2">
<TBODY>
  <tr>
    <td align="middle" bgColor="#000000" vAlign="center"><font color="#ffcc33" face="Arial"
    size="+3">CAPÍTULO I. Orígenes</font><br>
    <font color="#ffcc33" size="+1"><u>TechFacts 95</u></font> </td>
  </tr>
</TBODY>
</table>
</center></div>

<p><br>
</p>

<p align="center"><font color="#ffcc33" size="+1"><u>Diciembre 1997</u></font><br>
<br>
</p>
<div align="center"><center>

<table border="0">
<TBODY>
  <tr>
    <td align="middle" bgColor="#ffcc33" vAlign="center"><font color="#000000" size="+2"><b>Indice</b></font>
    </td>
  </tr>
  <tr>
    <td align="left" vAlign="center"><a
    href="http://users.vr9.com/wktrelz/tktk/eporc1.htm#unpoco"><font color="#ffcc33"
    face="Arial" size="3"><u><b>* UN POCO DE TODO:</b></u></font></a><br>
    <br>
    - Agradecimientos<br>
    - ¿Qué es eso de crackear?<br>
    - ¿Por qué crackear?<br>
    - ¿A quién va dirigido este curso?<br>
    - ¿Qué es lo que vamos a aprender?<br>
    - ¿No estaremos quitando el pan a los programadores de aplicaciones?<br>
    - ¿Qué necesito pa esto de crakear?<br>
    <br>
    <br>
    <a href="http://users.vr9.com/wktrelz/tktk/eporc1.htm#ideas"><font color="#ffcc33"
    face="Arial" size="3"><u><b>* IDEAS BÁSICAS SOBRE CRACKING:</b></u></font></a><br>
    <br>
    <a href="http://users.vr9.com/wktrelz/tktk/eporc1.htm#tools"><font color="#ffcc33"
    face="Arial" size="3"><u><b>* HERRAMIENTAS CRACK:</b></u></font></a> <br>
    <br>
    - Editor hexadecimal<br>
    - Desensamblador<br>
    - Debugger<br>
    <br>
    <br>
    <a href="http://users.vr9.com/wktrelz/tktk/eporc1.htm#esquemas1"><font color="#ffcc33"
    face="Arial" size="3"><u><b>* ESQUEMAS DE PROTECCION:</b></u></font></a> <br>
    <br>
    <br>
    <a href="http://users.vr9.com/wktrelz/tktk/eporc1.htm#esquemas2"><font color="#ffcc33"
    face="Arial" size="3"><u><b>* ESQUEMAS DE PROTECCIÓN BASADOS EN NÚMEROS DE SERIE:</b></u></font></a>
    <br>
    <br>
    - Acerca de los programadores<br>
    - Análisis de esquemas con número de serie<br>
    - ¿Cómo atacar?<br>
    - Otro punto de ataque<br>
    - Comparación de ataques<br>
    </td>
  </tr>
</TBODY>
</table>
</center></div>

<p><br>
<br>
</p>

<table bgColor="#000000" border="4">
<TBODY>
  <tr>
    <td align="left" vAlign="top"><font size="+0"><b><a name="unpoco"><font color="#ffcc33"
    face="Arial" size="3">UN POCO DE TODO:</font></a><br>
    <br>
    <p><b>¡Saludos Familia !</b> </p>
    <p><b>He decidido crear esta serie de capítulos con un objetivo puramente educativo (sin
    ningún tipo de obscuro interés comercial). Mi objetivo es ayudar a los nuevos crackers
    en sus primeros pasos.</b> </p>
    <p><b><font color="#00ff00">Agradecimientos</font></b> </p>
    <p><b>Al TodoPoderoso +ORC, a su acólito +FRAVIA y a los miembros de WKT por su apoyo.</b>
    </p>
    <p><b><font color="#00ff00">¿Qué es eso de crackear?</font></b> </p>
    <p><b>Crackear es el arte de reventar protecciones software/hardware con fines
    intelectuales, personales pero no lucrativos. Crackear también se llama ingeniería
    inversa (Reverse Engineering), ya que sin el programa fuente se es capaz de analizar el
    comportamiento del programa y modificarlo para tus intereses.</b> </p>
    <p><b><font color="#00ff00">¿Por qué crackear?</font></b> </p>
    <p><b>Vivimos en un una sociedad que da asco. Es inconcebible que se destruyan o penalicen
    la producción de productos básicos (cereales,lácteos...) en aras de una estabilidad de
    precios.Vivimos en una sociedad donde el 95% de la gente se ve sometida al control de un 5
    %. Toda persona debería tener un mínimo de recursos para ser feliz,pero esto no es así.</b>
    </p>
    <p><b>El noble arte del crakeo es una herramienta para distribuir la riqueza entre la
    sociedad. Si necesitas un programa (que tienes en un CD-ROM) y no tienes una cuenta en un
    banco USA, ni 30 dólares, ¿por qué narices tienes que esperar y pagar si lo necesitas?,
    crackealo y publica el crack en Internet. Así ayudarás a la gente menos afortunada que
    está axifiada por esta sociedad desigualitaria.</b> </p>
    <p><b><font color="#00ff00">¿A quién va dirigido este curso?</font></b> </p>
    <p><b>Este curso va dirigido a toda persona con interés en el crack y/o con la filosofía
    crack. Sin olvidar a los programadores.</b> </p>
    <p><b><font color="#00ff00">¿Qué es lo que vamos a aprender?</font></b> </p>
    <p><b>Dejaremos de un lado el añorado DOS, para centrarnos en cracks para programas en
    W95.</b> </p>
    <p><b><font color="#00ff00">¿No estaremos quitando el pan a los programadores de
    aplicaciones?</font></b> </p>
    <p><b>Los programadores viven muy bien a costa de los royaltis que pagan las grandes
    empresas y esos repugnantes yupis encorbatados con escased de neuronas. Además, un
    programa crakeado es más conocido y utilizado que uno que no lo esté. Digamos que el
    crack es una forma de publicidad. Baste recordar el compilador de Pascal de la casa
    Borland. Originalmente fue copieteado y distribuido casi libremente hasta la saciedad.
    Borland conocía este hecho y por eso no introdujo ningún tipo de protección. Al cabo de
    poco tiempo, esos estudiantes se convirtieron en programadores que reclamaban a sus
    empresas la compra del compilador que sabían utilizar, el Pascal de Borland. Si las casas
    de soft ya son ricas sin nuestro dinero, ¿a que estado de corrupción se llegaría si lo
    tuvieran?. Aunque parezca extraño este ensayo está dedicado a formar a los programadores
    , mostrándoles sus defectos y el camino para producir software de calidad.</b> </p>
    <p><b>En último caso depende de la conciencia de cada uno, si crees que un programador ha
    realizado una buena aplicación, que te es útil y que además está bien programada,
    entonces obra adecuadamente y recompénsalo registrándote. A decir verdad sólo he
    encontrado un programa de este estilo</b> </p>
    <p><b><font color="#00ff00">¿Qué necesito pa esto de crakear?</font></b> </p>
    <p><b>- Interés y PazYCiencia.</b> </p>
    <p><b>- Algún conocimiento de ensamblador. Cuanto más conozcas mejor crackearás, pero
    para este curso mas bien poco, intentaré hacer las cosas fáciles.</b> </p>
    <p><b>- Ayuda de otro cracker más experto (por ejemplo Estado+Porcino)</b> </b></font></td>
    <td>&nbsp;</td>
  </tr>
</TBODY>
</table>

<p><br>
<br>
</p>

<table bgColor="#000000" border="4">
<TBODY>
  <tr>
    <td align="left" vAlign="top"><b><a name="ideas"><font color="#ffcc33" face="Arial"
    size="3">IDEAS BÁSICAS SOBRE CRACKING</font></a><br>
    <br>
    Un programa no es más que un montón de instrucciones (haz, esto, haz lo otro), una tras
    otra. Estas instrucciones, (en general) están en memoria, parte de ellas se encargan de
    impedir la ejecución del resto (el verdadero programa). Resumiendo, tienes un bonito
    programa tras una puerta (esquema de protección), nuestro objetivo es reventar la puerta,
    buscar la llave,pasar por las rendijas,quemarla..., como puedes ver una cantidad
    inagotable de ataques. <br>
    <br>
    Un pequeño inciso, sólo puedes reactivar instrucciones que se encuentren en el programa.
    Por ejemplo, si se ha desactivado la opción de salvar, puede ser que el conjunto de
    sentencias para salvar el programa esté presente pero desactivado, o bien que simplemente
    no esté. Si están las sentencias, se pueden reanimar, sino están entramos en un mundo
    diferente, una evolución del cracking, la apasionante Reconstrucción Software, pero eso
    será tema de otro capítulo.<br>
    <br>
    <b><a name="tools"><font color="#ffcc33" face="Arial" size="3">HERRAMIENTAS CRACK</font></a><br>
    <br>
    Demos un breve repaso a las principales herramientas que utilizaremos a lo largo del
    curso. Existen otras muchas herramientas que las comentaré cuando nos sean necesarias.<br>
    <br>
    <b>Editor hexadecimal<br>
    <br>
    Los programas no son más que un conjunto de instrucciones y cada instrucción no es más
    que un conjunto de bits, pero donde demonios se guardan esos bits?. <br>
    <br>
    Los bits del programa se localizan en los ficheros, p.e. las instrucciones del programa de
    compresión arj se guardan en el fichero arj.exe. Hay algunos programas que no guardan
    todas sus instrucciones en único fichero, si no en varios, un ejemplo de esto son los
    programas que utilizan librerías dinámicas (o dll) <br>
    <br>
    Un editor hexa, no es más que un programa, que permite &quot;editar&quot; los ficheros de
    instrucciones de otros programas, osea, que permite ver,modificar,copiar,pegar... los bits
    de los programas. Para simplificar la cosa no se muestran los bits a pelo, sino que se
    muestran en hexadecimal, de ahí su nombre. Nosotros lo utilizaremos para alterar el
    comportamiento de los programas. Supongamos que conocemos la instrucción sentencia de la
    rutina de protección que debemos modificar, sea jz 23 y queremos modificarla por jnz 23,
    bien como toda instrucción no es más que un conjunto de bits, sea 0110 para jz 23 y 1001
    para jnz 23, sólo nos queda buscar estos bits dentro del fichero ejecutable del programa
    (que es, en general, el contiene las sentencias del programa). Como usamos un editor hexa,
    debemos buscar la secuencia de un unos y ceros en hexa en el fichero del programa que
    queremos modificar. Si la secuencia que buscamos es muy común deberemos utilizar las
    instrucciones que se encuentran entorno a la instrucción a modificar.<br>
    <br>
    Esto es muy importante, sólo debe existir una localización del patrón de búsqueda en
    el fichero, si existe más de una, debemos añadir a la búsqueda las sentencias de
    alrededor, sino se corre el riego de modificar la sentencia equivocada, lo que provoca
    casi siempre un &quot;cuelgue&quot;.<br>
    <br>
    Un no es más que una modificación de las instrucciones de un fichero, así pues para
    hacer un crack debemos saber que instrucciones modificar y en qué fichero. Una vez
    crackeado el fichero, el programa se comportará siguiendo la nueva sentencia que le hemos
    modificado. <br>
    <br>
    Hay un montón de editores hexa, yo os recomiendo UltraEdit-32 Professional, os lo podéis
    bajar de <font size="+0"><a href="http://ftpsearch.ntnu.no/">http://ftpsearch.ntnu.no/</a><br>
    <br>
    (excelente herramienta de búsqueda en la Web, utilízala cuando no encuentres algún
    fichero) busca w32dasm. Yo utilizo la versión 4.31a. Cada cracker tiene su editor
    favorito, !encuentra el tuyo!. Este programa es shareware, así que tendrás que
    crackearlo, recuerda : lo primero que tienes que crakear son tus propias herramientas. Si
    no puedes crackearlo, busca otro editor hexa, los hay a montones. <br>
    <br>
    <b>Desensamblador <br>
    <br>
    Un desensamblador toma un fichero de instrucciones en hexa y lo convierte a lenguaje
    ensamblador. El lenguaje ensamblador, es el conjunto de sentencias que entiende el
    microprocesador (tu Pentium o mi 486). El procesador es el corazón del ordenador, todas
    las sentencias son ejecutadas por él y sólo por él. Por ejemplo un 43 en hexa se
    transforma en inc eax. Se necesitan algunos conocimientos de ensamblador pa esto de
    crackear. <br>
    <br>
    Nosotros usaremos el desensamblador para crakear con la técnica de la lista muerta que
    veremos más adelante. <br>
    <br>
    Puedes pillar un magnífico desensamblador para W95 en <a
    href="http://www/expage.com/page/w32dasm">http://www/expage.com/page/w32dasm</a> , es
    shareware, así que deberás crackearlo. Próximamente le dedicaremos un capítulo al
    w32dasm y aprenderemos a crackearlo. Yo utilizo la versión 8.9, aunque una posterior es
    también útil. <br>
    <br>
    <b>Debugger<br>
    <br>
    Un debugger permite ejecutar instrucción a instrucción (instrucciones en ensamblador, se
    entiende) un programa, por tanto también ejecutará instrucción a instrucción la rutina
    de protección, ya que es parte del programa. Esto nos permitirá analizar su
    comportamiento. <br>
    <br>
    El mejor debugger para W95 es sin duda el Softice quo te lo puedes bajar de <a
    href="http://www.numega.com/">http://www.numega.com</a> , es sin duda uno de los mejores
    programas que he visto en mi vida. Te recomiendo que te bajes también los manuales. El
    Softice es una de las mejores herramientas cuanto más domines al Softice, mejor
    crakearás, y te aseguro que se pueden realizar verdaderas maravillas con él. Para trazar
    (esto es, pasar el debug) a programas MS-DOS, puedes utilizar versiones anteriores del
    Softice o utilizar algunos de los excelentes debugger que hay para Dos como el SymbDebug. <br>
    <br>
    Os indicaré un par de consejos y trucos para el Softice. <br>
    <br>
    --&gt; Instalación<br>
    <br>
    Haz la prueba de pantalla, si te la saltas, lo más seguro es que cuando actives el
    Softice se te quede la pantalla a rayas. Busca el driver de la tarjeta de vídeo que
    tengas instalada en W95 dentro de la lista que se ofrece. Aunque la encuentres, haz la
    prueba de pantalla, es posible que no funcione correctamente. Si no encuentras tu tarjeta
    de vídeo o tienes problemas de pantalla, corta la instalación y selecciona
    &quot;Adaptador de Vídeo Standard VGA&quot;, reinstala el Softice y utiliza ese mismo
    driver para la prueba de pantalla. Si sigues teniendo problemas te remito a la Doc del
    Softice (que deberías haberte bajado). Particularmente, con el adaptador Standard VGA no
    he tenido nunca problemas. Hay por ahí sueltos una ampliación de drivers de tarjetas
    para Softice, búscalos si no quieres pasa a la VGA Standard. <br>
    <br>
    Activa la opción de ratón, te evitará escribir bastantes secuencias hexa de
    instrucciones, te permitirá moverte libremente por las ventanas, seleccionar, copiar y
    pegar texto así como redimensionar las ventanas. <br>
    <br>
    ---&gt;Configuración <br>
    <br>
    El Loader es una pequeña utilidad que permite especificar el programa que queremos
    depurar y además nos permite configurar el Softice, En Edit/SoftIce Initialization
    Settings/Initialization string pon X;wl;wr;wd7; code on; y en Histoy Buffer Size pon 512 <br>
    Abre el fichero winice.dat (dentro del directorio de instalación del Softice) , toda
    línea del tipo EXP=c:\windows\system\system.drv , quítale el punto y como inicial.<br>
    <br>
    ---&gt;Ejecución<br>
    <br>
    El Softice debe cargarse siempre antes que W95. Si estas en W95, reinicializa en modo
    MS-DOS y ejecuta WINICE.EXE, este cargará el Softice y W95. Te recomiendo que utilices un
    fichero bat. <br>
    <br>
    Las ventanas que aparecen son <br>
    <br>
    Ventana de registros de la CPU (wr). A los típicos se ha añadido una E así se
    diferencia los registros normales que admiten 16 bits, de los registros que soportan 32
    bits. Por ejemplo, ax se llama ahora eax. Siempre podremos referencias a ax, sabiendo que
    nos quedaremos con 16 bits últimos de eax. <br>
    <br>
    Ventana de datos de la CPU (wd). Muestra la memoria en formato hexa, ahí se pueden
    apreciar los datos que maneja el programa, entre otras cosas. <br>
    <br>
    Ventana de código (wc). Muestra, la dirección de memoria en la que se encuentra la
    instrucción, la codificación hexa de la instrucción y la instrucción en ensamblador.<br>
    <br>
    Ventana de control, el la que aparece arriba el nombre del programa que estamos trazando.
    Aquí es donde introduciremos los comandos del SoftIce.<br>
    <br>
    He aquí algunos comandos fundamentales para el Softice: <br>
    <br>
    <i>CTRL+D<br>
    <br>
    </i>Conmuta de W95 al Softice y viceversa. No te asustes por el pantallazo ni por el
    aspecto cutre inicial, llegarás a quererlo, créeme. Si salen rayas, vuelve a leer el
    apartado --&gt;Instalación <br>
    <br>
    <i>F4<br>
    <br>
    </i>Estando en Softice, te permite echar un ojo al estado actual en W95 sin necesidad de
    conmutar. <br>
    <br>
    <i>F8<br>
    <br>
    </i>Ejecuta una instrucción, las modificaciones en los registros del sistema aparecen de
    diferente color. Si la instrucción es una llamada a una rutina, se ejecutarán una a una
    todas las instrucciones de la rutina llamada. <br>
    <br>
    <i>F10<br>
    <br>
    </i>Ejecuta una instrucción, las modificaciones en los registros del sistema aparecen de
    diferente color. Si la instrucción es una llamada a una rutina, se ejecutan de golpe
    todas las sentencias de la rutina llamada. <br>
    <br>
    <i>F11<br>
    <br>
    </i>Ejecuta de golpe todas las instrucciones de la rutina actual y se para el la
    instrucción siguiente de la rutina padre que llamó a esta rutina. Esto nos permite
    trazar al padre, estando en una rutina hija. En cuanto la uses menudo verás que no es tan
    complicado como parece. <br>
    <br>
    <i>F12<br>
    <br>
    </i>Ejecuta todas las sentencias hasta el primer ret (incluido) <br>
    <br>
    <i>bpx nombreRutina<br>
    <br>
    </i>Salta al Softice cuando se ejecuta la rutina cuyo nombre es nombreRutina. Ejemplo bpx
    messageboxa saltará al Softice cuando el programa muestre una ventana de mensaje del tipo
    mensaggebox.<br>
    <br>
    <i>bpx dirInstrucción<br>
    <br>
    </i>Salta al Softice cuando se ejecuta la instrucción que está es la dirección de
    memoria dirInstrucción.<br>
    <br>
    <i>bpr dirIni dirFin rw<br>
    <br>
    </i>Salta al Softice cuando hay un acceso de lectura o escritura en las direcciones
    dirIni,dirFin ambas incluidas. Ejemplo bpr 100 109 rw que puesto de otra forma más fácil
    de expresar, nos queda algo como bpr 100 100+9 rw <br>
    <br>
    <i>s l dir tam'cad'<br>
    <br>
    </i>Busca la cadena cad a partir de dir hasta dir+tam. Esta sentencia casi siempre tendrá
    este aspecto. Ejemplo s 30:00 l ffffffff 'cad' . Las comillas son importantes. 30:00 es la
    dirección de comienzo del segmento de datos, osea la dirección de memoria donde están
    los datos del programa y ffffffff es el tamaño del segmento de datos, como veréis hay
    4GB de espacio para almacenar datos. <br>
    <br>
    <i>d registro<br>
    <br>
    </i>Muestra en la ventada de datos el contenido de lo que hay a partir de la dirección
    guardada en registro. Ejemplo d eax muestra a lo que apunta eax.<br>
    <br>
    <i>d dirección<br>
    <br>
    </i>Muestra en la ventada de datos el contenido de lo que hay a partir de la dirección.<br>
    <br>
    <i>d nomRutina<br>
    <br>
    </i>Muestra en la ventada de datos el contenido de lo que hay a partir de la dirección
    donde comienza la rutina nomRutina. <br>
    <br>
    <i>Impr Pant<br>
    <br>
    </i>Vuelca el contenido de la pantalla por la impresora, quizás tengas que darle varia
    veces hasta que el buffer de la impresora se llene. </b></b></font></b></b></b></td>
    <td>&nbsp;</td>
  </tr>
</TBODY>
</table>

<p><br>
<br>
</p>

<table bgColor="#000000" border="4">
<TBODY>
  <tr>
    <td align="left" vAlign="top"><b><a name="esquemas1"><font color="#ffcc33" face="Arial"
    size="3">ESQUEMAS DE PROTECCION</font></a><br>
    <br>
    Citaré algunas de las técnicas utilizadas por los programadores para proteger su soft.<br>
    <br>
    - Números de Serie.<br>
    <br>
    - Cripple Software (software limitado), en diversas variantes: <br>
    <br>
    * Tiempo limitado a meses , días, minutos.. <br>
    <br>
    * Número de ejecuciones o usuarios limitado. <br>
    <br>
    * Funciones deshabilitadas. <br>
    <br>
    - Protecciones por discos o CD-ROM llave. <br>
    <br>
    - Protecciones anti herramientas crack <br>
    <br>
    * Antidebuggers.<br>
    <br>
    * Antidescompiladores. <br>
    <br>
    * Antidesensambladores. <br>
    <br>
    * Encriptación parcial o total. <br>
    <br>
    - Ninguna de las anteriores. <br>
    <br>
    <b>Acerca de los programadores <br>
    <br>
    Sólo dos cosas: <br>
    <br>
    a) En general son perezosos y a veces estúpidos. <br>
    b) Nunca les creas. <br>
    La opción a) es clara, sus esquemas de protección son arcaicos, apenas han sufrido
    modificaciones, tan sólo incorporan trucos viejos sobre esquemas bien conocidos.
    Programas en lenguajes de alto nivel tipo C++, Visual Basic, estos compiladores se basan
    en librerías bien conocidas. El programador no tiene el amor propio de crear su propia
    rutina de protección en ensamblador, prefieren dejarla en manos de compiladores que crean
    código ensamblador ineficiente y fácilmente legible. ¿A qué se debe todo esto?, a su
    mentalidad comercial de la vida, no trabajan por placer, son esclavos de su trabajo,
    verdaderos zombies andantes. Lo importante es acabar y pronto no importa la calidad del
    soft o las quejas del estúpido usuario por la lentitud del programa o por los
    &quot;cuelgues&quot;.<br>
    <br>
    Una breve disgresión, no os habéis preguntado por que las versiones de los programas
    salen como churros cada 2 días. La respuesta es que se dejan a propósito las cosas sin
    hacer o mal hechas para que al cabo de dos días se pueda sacar una flamante nueva
    versión con una leve modificación la cual debes comprar para no quedarse obsoleto, Dios
    mío que abominación! <br>
    <br>
    Respecto a b) baste decir que siempre tratan de encubrir sus errores con malolientes
    mentiras.<br>
    PROGRAMADORES, leed esto y aprended, pero que digo, no tenéis tiempo ni para joder, ni
    para ver por donde os joden....:-) <br>
    <br>
    <b><a name="esquemas2"><font color="#ffcc33" face="Arial" size="3">ESQUEMAS DE PROTECCIÓN
    BASADOS EN NÚMEROS DE SERIE</font></a> <br>
    <br>
    Ésta es una &quot;antigua&quot; técnica de protección utilizada por las toneladas de
    shareware que nos inundan, basta comprarse un CD por 4 perras y ver 650 MB de programas
    basura, en general, deseosos de exprimir nuestras carteras. Veamos como funcionan. <br>
    <br>
    El programa puede ser total o parcialmente funcional, pero posee estúpidas ventanas que
    nos recuerdan que somos usuarios no registrados, o bien pitidos mal sonantes o mensajes
    perennes proclamando que les mandemos dinero. A veces, pasado cierto tiempo o pasado un
    número de ejecuciones, el programa deja de funcionar. Todo esto inconvenientes se
    resuelven llamando a la casa que construyó el software (imaginad lo que puede costar una
    llamadita o un Fax a un pueblo mal oliente del esto de Utah en USA), o bien mandando un
    e-mail. En cualquier caso hay que indicar el número de VISA donde ellos clavarán sus
    garras para rellenar sus ya nutridas arcas. Una vez desplumado recibimos por e-mail o por
    teléfono una palabra mágica, un número de serie, una password, o lo que sea, yo lo
    llamaré &quot;pwd&quot;. Esta pwd desbloquea el programa y/o elimina las estúpidas
    ventanas recordatorio. <br>
    <br>
    <b>Análisis de esquemas con número de serie <br>
    <br>
    En general existen dos formas en las que trabajan las rutinas de protección de número de
    serie: <br>
    <br>
    a) Número de serie independiente del usuario. <br>
    b) Números de serie adaptados al usuario. <br>
    a) si extraemos una pwd, ésta servirá a todos los usuarios. Una pwd válida se
    diferencia de una inválida (por las muletas, es un chiste) por la presencia de ciertos
    caracteres en posiciones fijas (p.e. el carácter 8 debe ser una 'C', el 10 un '-'). Toda
    pwd que cumpla las restricciones será una pwd válida. Por norma, casi todas las pass
    incorporan el carácter '-', 2b en hexa. A veces no se requieren caracteres fijos , sino
    que la suma ASCII cumpla cierta condición. Cada letra del alfabeto y cada carácter
    numérico tiene una cantidad asociada, su código ASCII (p.e. par el acute0acutees el 30
    en hexa o el 40 en decimal). La técnica consiste en sumar el código de cada carácter y
    comprobar la suma (que a veces se llama checksum) con una cierta cantidad. Una variante es
    modificar el valor ASCII a través de una tabla que asocia a cada carácter un número
    distinto. <br>
    <br>
    Crackear esto es fácil de crackear: <br>
    <br>
    cmp suma,sumacorrecta ----&gt;cmp suma,sumacorrecta <br>
    jz ok --------------------&gt;jnz ok <br>
    Es posible mezclar las tres técnicas, caracteres fijos, cheksum y modificación del
    código ASCII. En un capítulo próximo veremos un ejemplo de esto. <br>
    <br>
    b) En este caso se utiliza el nombre, los apellidos, o el nombre de la empresas o todo
    junto para generar un pwd. Aquí las técnicas son más imaginativas: coger cierto
    caracteres y repetirlos hasta llegar a un tamaño, usar el código ASCII de ciertas
    caracteres como índice de una tabla de encriptación...En fin, depende de las paranoias
    del programador. Lo cierto es que se debe generar la pwd correcta para nuestros dato y
    ésta se debe comparar con la introducida. Aquí es donde podemos atacar ,en al
    comprobación. Realmente no hace falta crackear, basta con copiar la pwd correcta e
    introducirla como nuestra pwd, o bien crackear las sentencias de comprobación para que
    sirva cualquier pass. Lo primero es mejor ya que nos servirá para futuras versiones. <br>
    <br>
    Se puede mezclar ambas técnicas, como veremos en un capítulo próximo, y generar un
    checksum para una cierta cadena extraída a partir de los datos del usuario y comprobar el
    cheksum de nuestra cadena. <br>
    <br>
    <b>¿Cómo atacar? <br>
    <br>
    Antes de ir como unos desposeídos a reventar el programa, es totalmente necesario echar
    un vistazo, ver el posible esquema de protección y los posibles puntos de ataque. En
    general no hay que buscar mucho, los puntos débiles tiene un letrero rojo que dice &quot;
    Hey estoy aquí&quot;. <br>
    <br>
    En el caso de los esquemas basados en números de serie, la cosa está clara: esos
    estúpidos mensajes recordatorios son la puerta de entrada. Si somos usuarios no
    registrados aparecen, si nos registramos desaparecen. Por tanto debe haber algo que
    indique cuando deben o no aparecer, este algo es un flag, que no es más que un conmutador
    (como el de una bombilla). Cuando está en ON aparecen los mensajes, cuando en OFF
    desaparecen. En nuestro contexto, un flag no es más que una posición dentro de la
    memoria con un cierto valor. La memoria del ordenador es como un cartón de huevos (1
    huevo = 1 bit), donde cada hueco tiene un número diferente al que se le llama dirección
    de memoria. En cada hueco puede haber un huevo (valor 1) o no haberlo (valor 0). Los
    agujeros se agrupan, 8 agujeros es un Byte, 1024 Bytes es un MegaByte o MB, 1024 MB es un
    GigaByte o GB, 1024 GB es un TeraByte o TB. Fácil, ¿verdad?. La memoria está compuesta
    de bits, estos bits se pueden interpretar de muchas formas, flags, datos, instrucciones.
    Por ejemplo 01010101 puede ser un flag de activación, la cadena &quot;hola&quot; o lo
    sentencia pinta la pantalla, depende de como lo consideremos. En el caso de tomarlo como
    instrucciones, se habla de dirección de la instrucción en memoria, que no es más que la
    dirección del primer del primer bit que la compone.<br>
    <br>
    El valor que podemos encontrar en un flag puede variar. Para ON podemos encontrar un 1 y
    para OFF un 0. Se puede usar la llamada lógica negada y tiene en ON un 0 y en OFF un 1.
    Todo lo que se pueda hacer con 0 y 1, se pude reconvertir cambiando los 0 por 1 y los 1
    por 0. Una &quot;mejora&quot; de los programadores es utilizar flags distintos a 0,1,
    cuán inteligentes!. Recuerdo cierto esquema que utilizaba el flag DEAD en hexadecimal.
    Los sistemas de numeración (como el hexadecimal o hexa para abreviar) son formas
    diferentes de contar y de representar cantidades. En base 10, la de toa la vida, se
    empieza en 0 y se acaba en 9. en hexa se comienza en 0 y se acaba en F
    (10=a,11=b,12=c,13=d,14=e,15=f). <br>
    <br>
    Veamos algo más práctico: <br>
    <br>
    cmp ax,flag; Compara el valor de ax con el valor del flag <br>
    <br>
    jz mensajes; Si son iguales muestra los mensajes. <br>
    <br>
    sigue: inc dx; Continúa normalmente. <br>
    <br>
    ..... <br>
    <br>
    mensajes: mov edx,45 <br>
    <br>
    ..... <br>
    <br>
    jmp sigue;Salta y continua normalmente. <br>
    <br>
    Este puede ser un esquema típico. Dependiendo del valor del flag se muestran los mensajes
    o no. <br>
    <br>
    Llegamos a la parte interesante, cada mensaje recordatorio debe tener una comprobación
    como la del ejemplo. Basta con analizar los mensajes recordatorio y descubrir la
    dirección de memoria del flag. Pero quién narices rellena el flag?. Obviamente debe
    haber como mínimo dos inicializaciones, una al comienzo de la ejecución del programa que
    pone al flag a OFF y la rutina de protección que lo debe poner a ON si la pwd es
    correcta. ¿Me sigues hasta ahora?. <br>
    <br>
    Es fácil ahora saber donde atacar, un crack elegante sería poner la inicialización al
    comienzo del programa a ON en vez de OFF. Recuerda esto: &quot; Un buen cracker debe ser
    ante todo elegante y sutil, nada intrusivo&quot;. <br>
    <br>
    <b>Otro punto de ataque<br>
    <br>
    Hasta ahora hemos visto que analizando los estúpidos mensajes se puede conocer la
    dirección de memoria del flag y a partir de ahí su inicialización. Pero en los esquemas
    basados en números de series existe un punto de entrada más claro aún que los flags: la
    propia rutina de protección. Veamos un método sencillo para llegar a ella. <br>
    <br>
    Si uno se va a la opción de registro e introduce un número de serie falso, aparecerá
    una estúpida ventana indicando que nos hemos equivocado: &quot;Soryy your password is
    invalid&quot; o algo parecido que traducido al cristiano es &quot;Tío te ha equivocado,
    JAAARL&quot;. Esto no es una vía de entrada, esto es una autopista de 1GB de carriles.
    Basta con pensar un poco, quién es la encargada de mandar este mensaje? ,evidentemente la
    propia rutina de protección, interesante verdad?. Ya sólo queda encerrar la rutina, ver
    como trabaja , cambiar un par de bytes (siempre de la forma más elegante posible) y
    listo, programa crackeado. <br>
    <br>
    <b>Comparación de ataques <br>
    <br>
    ¿Qué crack es mejor?, el de flags o de la rutina de protección?. Esto depende en gran
    medida de programa, de tus habilidades y del tipo de que dispongas. Con la rutina de
    protección se puede analizar en profundidad el esquema, ver como trabaja y hasta extraer
    tu propio número de serie, osea el número de serie que la empresa te da si te registras,
    pero esto requiere tiempo y esfuerzo, obteniendo una satisfacción moral e intelectual.
    Además, en la próxima versión del programa est pwd posiblemente funcionará y no
    necesitarás crackear de nuevo. Mediante cracks al flag, se requiere un tiempo menor, pero
    la próxima versión habrá que crackearla de nuevo (no importa seguro que estos
    estúpidos programadores habrán seguido la mismo patrón de protección). Un crack a la
    rutina de exige un conocimiento profundo de la misma, lo que puede llevar a tu propio
    generador de claves (igualito o seguramente mejor que el tiene la empresa). </b></b></b></b></b></b></b></td>
    <td>&nbsp;</td>
  </tr>
</TBODY>
</table>

<p><br>
<br>
</p>

<table bgColor="#000000" border="4">
<TBODY>
  <tr>
    <td align="left" vAlign="top"><p align="center"><b><u><font color="#ffcc33" face="Arial"
    size="3">CÓMO CRACKEAR TECHFACTS 95:</font></u> <br>
    <br>
    Objetivo: TechFacts 95.<br>
    Versión: 1.30 3/7/97<br>
    Nombre del ejecutable: Teckfct95.exe<br>
    Website: http://ourworld.compuserve.com/homepage/deansoft<br>
    Tamaño del ejecutable: 1.251.840 bytes.<br>
    Tipo de protección: Por número de serie.<br>
    Dificultad: ameba.<br>
    Tiempo de crackeo: 2 minutos.<br>
    Herramientas: SoftIce 3.0 y Editor Hexadecimal.<br>
    <br>
    <br>
    Siguiendo las recomendaciones de +ORC empezaremos por crackear nuestras propias
    herramientas crack. El programa en cuestión es una pequeña joya que nos permitirá,
    entre otras muchas cosas, rastrear las acciones de un determinado programa, buscar cadenas
    de caracteres en ficheros, trabajar con dll.. Generalmente,lo utilizo para rastrear
    programas de instalación, obteniendo información de los ficheros creados, las entradas
    de registro añadidas o borradas, ... <br>
    <br>
    Manos a la obra. El programa es un ejecutable que no necesita otro fichero para funcionar
    (cosa rara en estos días). Así pues, arranquemos el programa veamos lo que ocurre.
    Aparece una horrible ventana diciendo que utilicemos nuestra VISA o MASTERCARD y que
    soltemos los 19,99 dólares (unas 2500 pesetas) que tenemos para ir a tomar cervezas. <br>
    <br>
    Echemos un vistazo al programa. Entre otras cosas, hay una opción en TOOLS/WATCH SYSTEM,
    que nos permite rastrear un programa. En HELP/HELP TOPICS/ORDER FORM aparece una hoja de
    registro en la que nos avisa de que además tenemos que paga 2 dólares para gastos de
    envío, ¡cómo si costará 250 pelas enviar un mail con el número de serie!.<br>
    <br>
    En HELP/ABOUT TECHFACTS 95 encontramos un botón USE REG KEY. Aquí es donde tenemos que
    introducir nuestro Nombre (First name), apellidos (Last name) y el número de serie
    correspondiente que lo recibiremos por mail si pagáramos 19,99 dólares más 2 dólares
    de gastos de envío. Empecemos por aquí. <br>
    <br>
    Pongamos un nombre, un apellido y un número cualquiera y pulsemos el botón REGISTER.
    Entonces escuchamos un pitido y aparece una ventana de mensaje diciendo REGISTRATION KEY
    FAILED. Ahora ¡pensemos un poco!, apliquemos un poco de ZEN CRACKING. <br>
    <br>
    Lo único anormal es el pitido. Si tu fueras un programador y quisieras que pitará tu
    &quot;cacharro&quot; tienes dos opciones construirte un bonito programa en ensamblador que
    lo haga, o bien utilizar una función de pitido presente en alguna de las vomitivas
    librerías de funciones, también llamadas API. ¿ Qué piensas que ha hecho nuestro
    &quot;vago&quot; programador ?. ¡Bingo! ha utilizado la función MessageBeep de la
    librería USER32.DLL. Este un punto de ataque muy claro, aunque existen muchos otros. <br>
    <br>
    Apliquemos la técnica LIVE, es decir, utilizaremos el SoftIce. Reinicialicemos nuestro
    ordenador en modo Ms-Dos, lancemos el WinIce y volveremos a Windows.<br>
    <br>
    Abramos el LOADER de SoftIce y en FILE/OPEN MODULE seleccionemos el fichero Tekfct95.exe.
    Pulsemos Load o el botón con las ruedecillas dentadas. Nos aparece una ventana de mensaje
    del SoftIce diciendo que no puede cargar la tabla de símbolos, pulsemos el botón SÍ y
    aparecemos directamente en el SoftIce con la pantalla en modo texto. En este momento nos
    encontramos en la primera sentencia de nuestro programa. Pulsemos bpx messagebeep con esto
    tomaremos el control antes de que aparezca el pitido. Con Ctrl-D volvemos a Windoce y el
    programa sigue ejecutándose normalmente pero con un cebo en messagebeep. Elegimos la
    opción de registro y escribimos cualquier cosa en nombre, apellidos y número de serie,
    pulsamos el botón y aparecemos de bruces en : <br>
    <br>
    USER32!MessageBeep <br>
    <br>
    014F:BFF623C1 B148 MOV CL,48 **** Aparecemos aquí.**** <br>
    <br>
    014F:BFF623C3 EB12 JMP BFF623D7 <br>
    <br>
    Si pulsamos en este momento F12(continuar hasta un RET) nos situaremos en: <br>
    <br>
    014F:0047BA65 EB11 jmp 0047BA78 <br>
    <br>
    014F:0047BA67 6A30 push 00000030 <br>
    <br>
    014F:0047BA69 E822A7F8FF Call 00406190 **** Llamada a MessageBeep**** <br>
    <br>
    014F:0047BA6E B8BCBB4700 mov eax, 0047BBBC <br>
    <br>
    014F:0047BA73 E824BEFBFF call 0043789C **** Pintamos la ventana de error **** <br>
    En tu ordenador las direcciones de memoria pueden ser diferentes. <br>
    <br>
    ¡Sintamos el código!. Estamos en mitad de las sentencias de error, lo que implica que
    debe haber un salto condicional a este conjunto de sentencias de error. El salto debe ser
    condicional porque en caso de haber metido correctamente el número de serie habríamos
    obtenido algún tipo de mensaje de felicitación. Así pues, sólo debemos encontrar ese
    salto condicional y modificarlo. <br>
    <br>
    Miremos por encima de la dirección 014F:0047BA69, nos encontramos en 014F:0047BA65 un
    salto incondicional jmp 0047BA78, en una ejecución normal nunca llegaríamos a 0047BA67
    ya que siempre saltaríamos a 0047BA78. Por tanto, lo que debemos buscar es un salto
    condicional a la dirección 0047BA67. Si volvemos hacia atrás un poco con los cursores
    encontramos este bonito salto <br>
    <br>
    014F:0047B934 E89B73F8FF call 00402CD4 <br>
    <br>
    014F:0047B939 0F8528010000 jne 0047BA67 **** ¡BINGO! **** <br>
    <br>
    014F:0047B93F 8D45B7 lea eax, dword ptr [ebp-49] <br>
    <br>
    Hemos encontrado el salto, sólamente hay que modificarlo. Fijaos que el salto se produce
    después de una llamada a la rutina call 00402CD4 apostaría el pellejo a que esta es una
    rutina para comprobar si tu número de serie es correcto. Si no es igual (jne) salta a las
    sentencias de error. Si es igual continua ejecutándose. Hay muchas formas de invertir el
    salto: <br>
    <br>
    1.- Cambiar 0F8528010000 jne 0047BA67 por <br>
    <br>
    0F8500000000 jne 0047B93F <br>
    <br>
    2.- Cambiar 0F8528010000 jne 0047BA67 por <br>
    <br>
    404840484048 inc eax,dec eax, inc eax, dec eax, inc eax, dec eax <br>
    <br>
    La 1 es un salto neutro, sea igual o no siempre se ejecuta la sentencia siguiente. La 2 es
    la preferida por +ORC, cambia el salto por un conjunto de parejas incrementar -
    decrementar que dejan el registro eax sin cambios en su contenido.<br>
    <br>
    Solamente hay que tener en cuenta dos cosas para modificar el código, sustituir siempre
    el mismo número de bytes (cambias 2 bytes por 2 bytes) y que tus modificaciones sean una
    sentencia en ensamblador correcta. <br>
    <br>
    El SoftIce nos permite hacer cambios On-Fly, es decir, en ese mismo instante, pero el
    cambio no es permanente. Para ello, nos vemos obligados a utilizar algún editor
    hexadecimal, con el cual abriremos el fichero ejecutable, y buscaremos la cadena en
    hexadecimal E89B73F8FF0F8528010000 y la cambiaremos por E89B73F8FF0F8500000000. La cadena
    se encuentra en el offset 0X7AD34(los números en hexa llevan delante un 0X) que en
    decimal es 503092.<br>
    <br>
    Así pues tenemos que irnos al byte 503092 de fichero ejecutable y comenzar a hacer
    cambios. <br>
    <br>
    Ahora tendremos el ejecutable parcheado, si nos registramos nuestro número de serie
    siempre será aceptado. <br>
    <br>
    Un crack no es más que un pequeño programa que abre un fichero y cambia un par de bytes
    por otros. ¡Nada más sencillo! Sólo hay que saber qué bytes hay que cambiar. Cuantos
    menos bytes se cambien más elegante será el crack. <br>
    <br>
    Si habéis seguido todos los pasos habéis crackeado vuestro primer programa. Aun nos sois
    cracker pero estáis en la buena senda. Sólo hay que poner interés.<br>
    <br>
    Para gentes más avezadas, comentaré que el flag de activación se iniciativa
    correctamente en :0047BA5E mov byte ptr [004CF31A],00 La rutina de protección es bastante
    patética, con gran cantidad de código inactivo. Empieza en :47B5C0. Obviamente se
    podría haber hecho algún otro tipo de pero este es el más simple (se podría haber
    obtenido el número de serie real, o haber creado un generador de claves).El programador
    ha puesta a &quot;pelo&quot; la dirección de retorno en :47BA3F push 47BA54. Es un
    ridículo truco que nos hará perdernos si continuamos ejecutando normalmente, por ello es
    conveniente pulsar &quot;F12&quot; y mirar hacia por encima sin ejecutar sentencias.<br>
    <br>
    </b>Espero vuestras opiniones, sugerencias y ensayos en <font size="+0"><a
    href="mailto:estadoporcino@hotmail.com">estadoporcino@hotmail.com</a><br>
    En breve analizaremos tipos de protecciones mucho más interesantes. <br>
    <br>
    Recordad bebed de la fuente, buscad a +ORC en la red. </font><br>
    <br>
    </td>
  </tr>
</TBODY>
</table>


</body>
</html>
